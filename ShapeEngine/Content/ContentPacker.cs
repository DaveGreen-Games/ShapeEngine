using System.IO.Compression;

namespace ShapeEngine.Content;

/// <summary>
/// Packs all files from a folder structure into a single text file.
/// Each resource is stored as two lines: the first line is the file name with extension,
/// and the second line is the compressed, Base64-encoded file data.
/// </summary>
public static class ContentPacker
{
    
    /// <summary>
    /// Pack a folder structure of various content types into a single txt file.
    /// </summary>
    /// <param name="sourcePath">The path to the folder that should be packed.
    /// Goes through all subfolders as well.</param>
    /// <param name="outputPath">The path where the resulting txt file should be saved.</param>
    /// <param name="outputFilename">The name of the resulting txt file.</param>
    public static void Pack(string sourcePath, string outputPath, string outputFilename = "resources.txt")
    {
        string[] files = Directory.GetFiles(sourcePath, "", SearchOption.AllDirectories);
        List<string> lines = new List<string>();
        foreach (var file in files)
        {
            lines.Add(Path.GetFileName(file));
            var d = File.ReadAllBytes(file);
            lines.Add(Convert.ToBase64String(Compress(d)));
        }
        File.WriteAllLines(outputPath + outputFilename, lines);
    }
    
    /// <summary>
    /// Loads and unpacks a text file generated by the <see cref="Pack"/> method.
    /// </summary>
    /// <param name="path">The path to the packed txt file.</param>
    /// <param name="fileName">The name of the packed txt file.</param>
    /// <returns></returns>
    public static Dictionary<string, ContentInfo> Unpack(string path, string fileName = "resources.txt")
    {
        Dictionary<string, ContentInfo> result = new();
        var lines = File.ReadAllLines(path + fileName);
        for (int i = 0; i < lines.Length; i += 2)
        {
            string filenName = lines[i];
            string name = Path.GetFileNameWithoutExtension(filenName);
            string extension = Path.GetExtension(filenName);
            string dataText = lines[i + 1];
            var data = Convert.FromBase64String(dataText);
            result.Add(name, new(extension, Decompress(data)));
        }
        return result;
    }
    
    /// <summary>
    /// Compresses binary data using the Deflate algorithm using compression level <see cref="CompressionLevel.Optimal"/>.
    /// </summary>
    /// <seealso cref="DeflateStream"/>
    /// <seealso cref="MemoryStream"/>
    /// <param name="data">The binary data to compress.</param>
    /// <returns>The compressed binary data.</returns>
    private static byte[] Compress(byte[] data)
    {
        var output = new MemoryStream();
        using (var deflateStream = new DeflateStream(output, CompressionLevel.Optimal))
        {
            deflateStream.Write(data, 0, data.Length);
        }
        return output.ToArray();
    }

    /// <summary>
    /// Decompresses binary data that was compressed using the Deflate algorithm using compression mode <see cref="CompressionMode.Decompress"/>.
    /// </summary>
    /// <seealso cref="DeflateStream"/>
    /// <seealso cref="MemoryStream"/>
    /// <param name="data">The compressed binary data to decompress.</param>
    /// <returns>The decompressed binary data.</returns>
    private static byte[] Decompress(byte[] data)
    {
        var input = new MemoryStream(data);
        var output = new MemoryStream();
        using (var deflateStream = new DeflateStream(input, CompressionMode.Decompress))
        {
            deflateStream.CopyTo(output);
        }
        return output.ToArray();
    }

}


